{
  "name": "Error Handling",
  "nodes": [
    {
      "parameters": {
        "sendTo": "={{ $json.Email }}",
        "subject": "={{ $json.Subject }}",
        "emailType": "text",
        "message": "={{ $json.Body }}",
        "options": {
          "appendAttribution": false
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        0,
        0
      ],
      "id": "a748011a-1ea0-4668-aa3d-d30373848736",
      "name": "Gmail",
      "webhookId": "4d71ffd4-a74f-45b9-873c-25b3e0b0ef9c",
      "credentials": {
        "gmailOAuth2": {
          "id": "VkUyoINQUbGu0SWT",
          "name": "My Gmail account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Initialize an array to hold the output items\nlet outputItems = [];\n\n// Fetch all incoming items\nconst items = $input.all();\n\n// Function to flatten nested objects\nfunction flattenObject(ob) {\n  const toReturn = {};\n\n  try {\n    for (const i in ob) {\n      if (!Object.prototype.hasOwnProperty.call(ob, i)) continue;\n\n      if (typeof ob[i] === 'object' && ob[i] !== null) {\n        const flatObject = flattenObject(ob[i]);\n        for (const x in flatObject) {\n          if (!Object.prototype.hasOwnProperty.call(flatObject, x)) continue;\n          toReturn[`${i}.${x}`] = flatObject[x];\n        }\n      } else {\n        toReturn[i] = ob[i];\n      }\n    }\n  } catch (err) {\n    toReturn[\"error\"] = `Error while flattening object: ${err.message}`;\n  }\n\n  return toReturn;\n}\n\n// Loop over each incoming item\nfor (let i = 0; i < items.length; i++) {\n  try {\n    // Get the current item's JSON data\n    const incomingData = items[i]?.json;\n\n    if (!incomingData || typeof incomingData !== \"object\") {\n      outputItems.push({\n        json: {\n          error: `Invalid input at index ${i}: Expected an object but received ${typeof incomingData}`,\n        },\n      });\n      continue;\n    }\n\n    // Flatten the incoming data\n    const flattenedData = flattenObject(incomingData);\n\n    // Push the flattened data into the output array\n    outputItems.push({ json: flattenedData });\n  } catch (err) {\n    // Handle unexpected errors during processing\n    outputItems.push({\n      json: {\n        error: `Unexpected error at index ${i}: ${err.message}`,\n      },\n    });\n  }\n}\n\n// Return all the structured responses\nreturn outputItems;\n"
      },
      "id": "ac782faa-b259-4bf8-8aef-ba4525d2dd38",
      "name": "Prepare output",
      "type": "n8n-nodes-base.code",
      "position": [
        -848,
        112
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Please generate an email by filling in the blanks in the template below using the error details provided. The email must have exactly three sections, each starting with the labels: Subject:, Body:, and Email:.\n\n**Template:**\n\nSubject: Error Trigger Notification\n\nBody:\nHello,\n\nAn error has been triggered in the execution of your workflow. Below are the details:\n\n\n- Execution ID: {{ $json['execution.id'] }}\n- Workflow Name: {{ $json['workflow.name'] }}\n- Workflow ID: {{ $json['workflow.id'] }}\n- Execution URL: {{ $json['execution.url'] }}\n- Retry Of: {{ $json['execution.retryOf'] }}\n- Error Message: {{ $json['execution.error.message'] }}\n- Stacktrace: {{ $json['execution.error.stack'] }}\n- Last Node Executed: {{ $json['execution.lastNodeExecuted'] }}\n- Mode: {{ $json['execution.mode'] }}\n\nPlease review the error and take the necessary steps to resolve it.\n\nBest regards,\nN8N Error Handler\n\nEmail: davidgriffeyjr69@gmail.com\n\n**Error Details:**\n\n- Execution ID: {{ $json['execution.id'] }}\n- Workflow Name: {{ $json['workflow.name'] }}\n- Workflow ID: {{ $json['workflow.id'] }}\n- Execution URL: {{ $json['execution.url'] }}\n- Retry Of: {{ $json['execution.retryOf'] }}\n- Error Message: {{ $json['execution.error.message'] }}\n- Stacktrace: {{ $json['execution.error.stack'] }}\n- Last Node Executed: {{ $json['execution.lastNodeExecuted'] }}\n- Mode: {{ $json['execution.mode'] }}\n- Email Address: davidgriffeyjr69@gmail.com\n\n**Instructions:**\n\n- Replace each placeholder in brackets [ ] with the corresponding information from the error details.\n- Do not omit any labels or sections.\n- Ensure the final output includes all three labels: **Subject:**, **Body:**, and **Email:**.\n- Do not add any additional text or explanations outside of the template.\n\n**Please fill in the template now.**\n",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        -640,
        112
      ],
      "id": "09b00a4e-d927-4e83-ac84-202fe9351b31",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": "llama2-uncensored:7b",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOllama",
      "typeVersion": 1,
      "position": [
        -656,
        304
      ],
      "id": "d1531f2f-e67e-4e9c-a710-3c229345e7cd",
      "name": "Ollama Chat Model",
      "credentials": {
        "ollamaApi": {
          "id": "vnaDIcAAtGwvDi0D",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Eve's n8n Code node: Parse AI Agent output into structured fields\n// - Extracts Subject, Email, Body (excluding details/footer)\n// - Parses \"details\" lines into both a Details object and flattened root fields\n// - Handles multiple input items\n\n// ===== Utility helpers =====\nfunction normalizeNewlines(text) {\n  return (text || '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n}\n\nfunction toCamelKey(label) {\n  // Normalize: keep letters/numbers/spaces, turn separators to spaces, then camelCase\n  const cleaned = String(label)\n    .replace(/[_\\-]+/g, ' ')\n    .replace(/[^a-zA-Z0-9 ]+/g, ' ')\n    .trim()\n    .replace(/\\s+/g, ' ');\n  const parts = cleaned.toLowerCase().split(' ');\n  if (parts.length === 0) return '';\n  return parts\n    .map((p, i) => (i === 0 ? p : p.charAt(0).toUpperCase() + p.slice(1)))\n    .join('');\n}\n\nfunction parseKeyValueLine(line) {\n  // Matches: Key: Value   (tolerates extra spaces)\n  const m = line.match(/^\\s*([A-Za-z0-9 _\\-\\./]+?)\\s*:\\s*(.+)\\s*$/);\n  if (!m) return null;\n  const key = m[1].trim();\n  const value = m[2].trim();\n  return { key, value };\n}\n\nfunction extractFirstMatch(text, regex, group = 1) {\n  const m = text.match(regex);\n  return m ? m[group].trim() : '';\n}\n\nfunction buildBodyExcluding(text, exclusions) {\n  // Remove lines that match any exclusion predicate\n  const lines = text.split('\\n');\n  const kept = [];\n  for (const line of lines) {\n    const trimmed = line.trim();\n    const exclude = exclusions.some(fn => fn(trimmed));\n    if (!exclude) kept.push(line);\n  }\n  // Collapse leading/trailing empty lines\n  return kept.join('\\n').replace(/^\\s+|\\s+$/g, '');\n}\n\n// ===== Core parser =====\nfunction parseEmailBlock(rawText) {\n  const text = normalizeNewlines(rawText);\n\n  // Subject: first occurrence (case-insensitive, multiline)\n  const subject = extractFirstMatch(text, /^subject:\\s*(.+)$/im) || 'No Subject';\n\n  // Email: last occurrence (in case there are multiple email-like lines)\n  // Capture a reasonable email token\n  const emailMatches = [...text.matchAll(/^\\s*email:\\s*([^\\s<>()[\\]{},\"']+@[^\\s<>()[\\]{},\"']+)\\s*$/gim)];\n  const email = emailMatches.length ? emailMatches[emailMatches.length - 1][1].trim() : 'No Email';\n\n  // Find the \"details\" block start\n  // We treat the block as starting after a line that says \"Below are the details:\" (case-insensitive)\n  const lines = text.split('\\n');\n  let detailsStartIdx = -1;\n  for (let i = 0; i < lines.length; i++) {\n    if (/^\\s*below are the details\\s*:?\\s*$/i.test(lines[i])) {\n      detailsStartIdx = i + 1;\n      break;\n    }\n  }\n\n  // Collect detail key/value pairs\n  const details = {};\n  const detailLineIndexes = new Set();\n\n  if (detailsStartIdx !== -1) {\n    // Parse consecutive key:value lines until a blank or non key:value is encountered\n    for (let i = detailsStartIdx; i < lines.length; i++) {\n      const line = lines[i];\n      const trimmed = line.trim();\n\n      // Stop if blank line and we've already consumed some details\n      if (trimmed === '' && Object.keys(details).length > 0) break;\n\n      const kv = parseKeyValueLine(line);\n      if (!kv) {\n        // If we haven't started capturing yet, skip; if started, we can break on the first non-KV\n        if (Object.keys(details).length > 0) break;\n        continue;\n      }\n\n      const camel = toCamelKey(kv.key);\n      if (camel) {\n        details[camel] = kv.value;\n        detailLineIndexes.add(i);\n      }\n    }\n  }\n\n  // Build a clean Body:\n  // - Start from after the \"Subject:\" line (first occurrence), if found\n  // - Exclude the details block lines and Subject/Email lines themselves\n  // - Exclude a simple closing signature block that starts at \"Best regards,\" or \"Regards,\" (optional)\n  const subjectLineIndex = lines.findIndex(l => /^subject:/i.test(l.trim()));\n  const emailLineIndexes = new Set(\n    lines\n      .map((l, idx) => ({ l, idx }))\n      .filter(x => /^\\s*email:/i.test(x.l.trim()))\n      .map(x => x.idx)\n  );\n\n  // Optional: identify a closing salutation to trim tail\n  let salutationStart = -1;\n  for (let i = 0; i < lines.length; i++) {\n    if (/^\\s*(best regards|regards|sincerely)[\\s,]*$/i.test(lines[i].trim())) {\n      salutationStart = i;\n      break;\n    }\n  }\n\n  // Determine initial body region: from the line after Subject to either end or salutation\n  const bodyStart = subjectLineIndex >= 0 ? subjectLineIndex + 1 : 0;\n  const bodyEnd = salutationStart > bodyStart ? salutationStart : lines.length;\n\n  const candidateBody = lines.slice(bodyStart, bodyEnd).join('\\n');\n\n  // Define exclusions within candidate body\n  const exclusions = [\n    (t) => /^subject:/i.test(t),\n    (t) => /^email:/i.test(t),\n    (t, idx) => detailLineIndexes.has(idx), // index-aware exclusion handled below\n  ];\n\n  // Because one exclusion needs indexes, filter manually:\n  const candidateLines = candidateBody.split('\\n');\n  const keptLines = candidateLines.filter((line, localIdx) => {\n    const globalIdx = bodyStart + localIdx;\n    const trimmed = line.trim();\n    if (/^subject:/i.test(trimmed)) return false;\n    if (/^email:/i.test(trimmed)) return false;\n    if (detailLineIndexes.has(globalIdx)) return false;\n    return true;\n  });\n\n  const body = keptLines.join('\\n').replace(/^\\s+|\\s+$/g, '');\n\n  // Also return flattened details at root level\n  const flatDetails = { ...details };\n\n  return {\n    Subject: subject,\n    Body: body || 'No Body',\n    Email: email,\n    Details: details,\n    ...flatDetails,\n  };\n}\n\n// ===== Main: handle multiple input items =====\nconst outputItems = [];\n\nfor (let itemIndex = 0; itemIndex < items.length; itemIndex++) {\n  const item = items[itemIndex];\n  const outputText = (item.json && item.json.output) ? String(item.json.output) : '';\n\n  const parsed = parseEmailBlock(outputText);\n\n  // Push as a new output item\n  outputItems.push({ json: parsed });\n}\n\nreturn outputItems;\n"
      },
      "id": "acd7d190-efa1-4f7d-a47c-ed5e1218bb49",
      "name": "Prepare output1",
      "type": "n8n-nodes-base.code",
      "position": [
        -240,
        112
      ],
      "typeVersion": 2
    },
    {
      "parameters": {
        "chatId": "7536349742",
        "text": "={{ $json.Body }}",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        0,
        208
      ],
      "id": "14a1f76b-7266-45c1-8525-0278142d372d",
      "name": "Telegram",
      "webhookId": "fb2b18b8-22fe-4398-b401-7a074bcb6870",
      "credentials": {
        "telegramApi": {
          "id": "Ujc1jDXPUGNzZWxX",
          "name": "Telegram account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.errorTrigger",
      "typeVersion": 1,
      "position": [
        -1056,
        112
      ],
      "id": "f1bd2974-023b-4521-9d6e-365624e1966b",
      "name": "Error Trigger"
    }
  ],
  "pinData": {},
  "connections": {
    "Prepare output": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Prepare output1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare output1": {
      "main": [
        [
          {
            "node": "Gmail",
            "type": "main",
            "index": 0
          },
          {
            "node": "Telegram",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Trigger": {
      "main": [
        [
          {
            "node": "Prepare output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Chicago",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "cPOFPaFJ8vWgg1Ap"
  },
  "versionId": "0de5a2ed-262f-4235-80dd-dd2acb880655",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "28f6daa761b86ce20ee29f848a5407f3c1e49e1e82b9b173e64be4c19463438f"
  },
  "id": "cPOFPaFJ8vWgg1Ap",
  "tags": []
}